package views

import (
	"fmt"

	"github.com/ip812/blog/articles"
	"github.com/ip812/blog/templates"
	"github.com/ip812/blog/templates/components"
	"github.com/ip812/blog/templates/button"
	"github.com/ip812/blog/templates/code"
)

var ansiblePlusTailsclaleEqualGreatComboIDMetadata = articles.GetByID(articles.AnsiblePlusTailsclaleEqualGreatComboID)

templ ArticleAnsiblePlusTailscaleEqualGreatCombo() {
	@templates.Base() {
		<div class="flex flex-col min-h-screen justify-between w-full">
			<div class="flex flex-1 justify-center">
				<div class="mx-auto w-4/5 md:w-1/2 space-y-8 py-12 font-medium">
					<div class="mb-8 flex justify-center">
						@button.Button(button.Props{
							Href: "/p/public/articles",
						}) {
                            Go Back to Articles
						}
					</div>

					<header class="flex flex-col w-full justify-center items-center mb-2">
						<h1 class="text-3xl font-semibold leading-tight">{ ansiblePlusTailsclaleEqualGreatComboIDMetadata.Name }</h1>
					</header>

					<p class="my-0">
						Before we jump into the concrete setup, here’s a short explanation of why you might want this solution.
						Originally, remote machines were configured manually — you logged in, ran commands, and called it a day.
						As the number of machines grew and tasks became repetitive, people began writing ad-hoc shell scripts to automate them.
						That created another problem: many scattered scripts, each with its own conventions, which made maintenance hard.
						To solve that, teams adopted configuration-management tools like Ansible, Puppet, Chef, and Salt.
						Later, containerization and orchestration arrived (Docker and then Kubernetes). Kubernetes introduces useful abstractions for running and scaling distributed applications and is great when you manage hundreds or thousands of nodes.
						However, that abstraction and the added complexity are not always worth it — for small deployments (a single machine or a few machines), Kubernetes can be overkill.
						In those cases, a configuration-management approach like Ansible is usually simpler and sufficient.
						In this post I’ll show how to use Ansible to manage Docker containers on remote hosts that live in private networks — and how to access them securely using Tailscale so you don’t need to open public ports or manage SSH keys manually.
					</p>

					<p class="mt-4 mb-0">
						The idea is simple: if a machine is joined to our Tailscale network and SSH access is enabled, Ansible can connect to it because Ansible uses SSH.
						To run Ansible automatically whenever we change our repository, we’ll add a GitHub Actions workflow that runs on push.
						For the workflow runner to reach machines on Tailscale, we’ll temporarily add the runner to our Tailscale network using Tailscale’s GitHub Action.
						This demo configures two AWS VMs to:
					</p>
                    <ul class="list-disc list-inside my-0">
						<li>Install common utilities (tmux, vim, jq, etc.)</li>
						<li>Install Docker using Ansible roles/collections</li>
						<li>Run two Nginx containers on one VM and two Traefik containers on the other</li>
						<li>Keep both VMs inaccessible from the public internet — reachable only via Tailscale</li>
					</ul>
					<p class="mt-4 mb-0">
						Below is the Ansible setup used in the demo.
					</p>

					<div class="my-0">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/inventory.ini
[workers]
a1 ansible_host=aws-worker-1
a2 ansible_host=aws-worker-2` }
						}
					</div>

					<p class="mt-4">
						This is the inventory — how Ansible knows what hosts exist and how to reach them.
						We have two hosts (a1 and a2) in the <code>workers</code> group. When running playbooks you can target the group or individual hosts.
						The <code>aws-worker-1</code> and <code>aws-worker-2</code> entries are the MagicDNS hostnames assigned by Tailscale; you could also use IP addresses.
					</p>

					<div class="mt-6">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/requirements.yml
roles:
  - name: geerlingguy.docker
    version: 7.4.1

collections:
  - name: community.docker
    version: ">=3.0.0"` }
						}
					</div>

					<p class="mt-4">
						The <code>requirements.yml</code> file lists the Ansible roles and collections required by the playbooks.
						Here we use <code>geerlingguy.docker</code> to install Docker and <code>community.docker</code> to interact with Docker from Ansible.
					</p>

					<div class="mt-6">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`# ansible/playbook.yml
- name: Install dependencies
  hosts: workers
  become: yes
  roles:
    - base
    - geerlingguy.docker

- name: Install nginx on AWS Worker 1
  hosts: a1
  become: yes
  roles:
    - nginx

- name: Install traefik on AWS Worker 2
  hosts: a2
  become: yes
  roles:
    - traefik` }
						}
					</div>

					<p class="mt-4">
						This playbook installs common utilities and Docker on both hosts (the <code>base</code> and <code>geerlingguy.docker</code> roles), then configures Nginx on <code>a1</code> and Traefik on <code>a2</code>.
					</p>

					<div class="mt-6">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/roles/base/tasks/main.yml
- name: Install common utilities
  apt:
    name:
      - tmux
      - vim
      - jq
    state: present` }
						}
					</div>

					<p class="mt-4">
						The <code>base</code> role installs common utilities such as <code>tmux</code>, <code>vim</code>, and <code>jq</code>.
					</p>

					<p class="mt-4">
						Below are the Nginx tasks. Traefik is set up in a similar way.
					</p>

					<div class="mt-6">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/roles/nginx/tasks/main.yml
- name: Nginx Alpine
  import_tasks: nginx_alpine.yml

- name: Nginx Latest
  import_tasks: nginx_latest.yml` }
						}
					</div>

					<div class="mt-6">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/roles/nginx/tasks/nginx_alpine.yml
- name: Start nginx:alpine container
  community.docker.docker_container:
    name: nginx_alpine
    image: nginx:alpine
    state: started
    ports:
      - "8080:80"
    restart_policy: no` }
						}
					</div>

					<div class="mt-6">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/roles/nginx/tasks/nginx_latest.yml
- name: Start nginx:latest container
  community.docker.docker_container:
    name: nginx_latest
    image: nginx:latest
    state: started
    ports:
      - "8081:80"
    restart_policy: no` }
						}
					</div>

					<p class="mt-4">
						We import two task files that start <code>nginx:alpine</code> (exposed on port <code>8080</code>) and <code>nginx:latest</code> (exposed on port <code>8081</code>).
						Traefik is configured in a comparable way on the other host.
					</p>

					<p class="mt-4">
						One important operational detail: Ansible connects over SSH. A typical setup requires either opening port 22 or provisioning SSH keys on every host — both of which add operational overhead and increase the attack surface.
						Instead, we’ll use Tailscale (a mesh VPN) so the hosts don't need public ports. With Tailscale + its SSH support enabled on the host, Ansible can reach the machines over the private Tailscale network.
						At minimum, install Tailscale and join the host to your Tailscale network with the <code>--ssh</code> flag. A minimal setup looks like:
					</p>

					<div class="mt-6">
						@code.Code(code.Props{
							Language:       "bash",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`#!/usr/bin/env bash

apt-get update -y
apt-get install -y curl

curl -fsSL https://tailscale.com/install.sh | sh
tailscale up --authkey TAILSCALE_AUTH_KEY --hostname aws-worker-1 --ssh` }
						}
					</div>

					<p class="mt-4">
						To automate execution from CI, create a GitHub Actions workflow that:
						<ol class="list-decimal list-inside mt-2">
							<li>Checks out the repository</li>
							<li>Adds the runner to your Tailscale network (temporarily) using the Tailscale GitHub Action</li>
							<li>Installs Ansible roles</li>
							<li>Runs the Ansible playbook against the Tailscale-accessible hosts</li>
						</ol>
					</p>

					<div class="mt-6">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`# .github/workflows/ansible-run-playbook.yml
---
name: Ansible Run Playbook

on:
  push:
    branches:
      - main
    paths:
      - 'ansible/**'

jobs:
  run-playbook:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Set up Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      - name: Install Ansible roles
        run: ansible-galaxy install -r ansible/requirements.yml

      - name: Run Ansible playbook
        uses: dawidd6/action-ansible-playbook@v5
        with:
          playbook: ansible/playbook.yml
          options: |
            --inventory ansible/inventory.ini
            --user ubuntu
            --verbose` }
						}
					</div>

					<p class="mt-4 mb-0">
						That’s the gist of it: use Tailscale to avoid exposing SSH to the internet, and use a temporary, Tailscale-connected GitHub Actions runner to run Ansible against private hosts.
					</p>

					<ul class="list-disc list-inside mt-0 mb-0">
						<li>
							You can find the source code for this project
							<a href="https://github.com/ip812/infra/tree/002fd55652cd9c85fa288119230138fa775742c0" class="text-blue-600 hover:underline" target="_blank" rel="noopener noreferrer">
								here
							</a>.
						</li>
						<li>
							I also recorded a walkthrough video showing how to set up Tailscale and a GitHub Actions runner to run the Ansible playbook:
							<a href="https://www.youtube.com/watch?v=9ZkzPYZTazY" class="text-blue-600 hover:underline" target="_blank" rel="noopener noreferrer">
								Watch the video
							</a>.
							If you have questions or suggestions, feel free to comment below or reach out on social media.
						</li>
					</ul>

					<div class="mt-12">
						<h2 class="text-2xl font-bold mb-4">Comments</h2>
						<hr class="border-t-2 border-gray-300 mb-6"/>
						@components.CommentInputForm(components.CommentInputFormProps{
							ArticleID: articles.AnsiblePlusTailsclaleEqualGreatComboID,
						})
						<div
							id="comments"
							hx-get={fmt.Sprintf("/api/public/v0/articles/%d/comments", articles.AnsiblePlusTailsclaleEqualGreatComboID)}
							hx-target="#comments"
							hx-swap="innerHTML"
							hx-trigger="load"
						>
							<div class="mt-4">
								@templates.Spinner() {}
							</div>
						</div>
					</div>
				</div>
			</div>
			@templates.Footer()
		</div>
	}
}
