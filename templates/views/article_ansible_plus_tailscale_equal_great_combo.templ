package views

import (
    "fmt"
	"github.com/ip812/blog/articles"
	"github.com/ip812/blog/templates"
	"github.com/ip812/blog/templates/components"
	"github.com/ip812/blog/templates/button"
	"github.com/ip812/blog/templates/code"
)

var ansiblePlusTailsclaleEqualGreatComboIDMetadata = articles.GetByID(articles.AnsiblePlusTailsclaleEqualGreatComboID)

templ ArticleAnsiblePlusTailscaleEqualGreatCombo() {
	@templates.Base() {
		<div class="flex flex-col min-h-screen justify-between w-full">
			<div class="flex flex-1 justify-center">
				<div class="mx-auto w-4/5 md:w-1/2 space-y-8 py-12 font-medium">
					<div class="mb-8 flex justify-center">
						@button.Button(button.Props{
							Href: "/p/public/articles",
						}) {
                            Go Back to Articles
						}
					</div>

					<header class="flex flex-col w-full justify-center items-center mb-2">
						<h1 class="text-3xl font-semibold leading-tight">{ ansiblePlusTailsclaleEqualGreatComboIDMetadata.Name }</h1>
					</header>

				    <p class="my-0">
                        Before diving into the concrete setup I want to explain shortly why you might need such solution after all.
                        At the begiing the way people configuring remote machines were to manually go to the machines run some commands and call the day.
                        When the thing becaume to repetative and the number of machines grew, people started to write custom Shell scripts to automate the process.
                        But this created other issue - now there were a lot of small scripts everywhere, everyone had their own way of doing things and it was hard to maintain.
                        People then decided that it is time to make some more universal and robust way of managing their servers - the came the era of config management tools like Ansible, Puppet, Chef, Salt and etc.
                        The next logical think that came after Docker came to the scene was orchestrators most popular of which is Kubernetes.
                        The whole idea of Kubernetes was to include best practices for running containers and overall software on servers in a way that it allows the apps to run in distributed fashion and to be able to scale up and down as needed.
                        This is great solution when you have hundreds or thousands of machines to manage. The goal of Kubernetes is to create abstraction over the underlying infra and for the user it not no matter how much machines are running,
                        is some machine down, is some machine patching and so on. The idea is to hide everything under some API and Kubernetes to manage the indvidiual machines and for the users to nbe important I want to run application A and thats it.
                        Now the logical question arrise - is this abstraction needed in every case. And the answear is no - you have a single or a few machines this is overkill, you don't need that extra comlexity, because it doen't bring value to you.
                        In such cases conifig management tools in my opinion are more than enough to fulfill your needs.
                        And in this blog post I will show you how with Ansible you can manage docker containers on a remote host/hosts and even more- how this machines can be in private networks and access them via Tailscale
                        so to avaoid the need of open ports or management of SSH keys.
					</p>

				    <p class="my-0">
						So now let's deep dive into the setup.
                        The idea is that if a machine is added to out Tailscale network and if ssh access is enabled for that machine, Ansible should be able to connect to it, because Ansible uses SSH for connecting to remote hosts by using push model.
                        So in order to run Ansible every time we make a change to out configuration, we will add a GitHub Action workflow that will be triggered every time we push a change to our repository.
                        In order the Github Action runner to be able to connect to our Tailscale network, we will add the runner temporary to our Tailscale network by using Tailscale's GitHub Action.
					</p>

				    <p class="mt-4">
						The goal of this demo project is to configure 2 VMs on AWS to:
                        - Configure both VM with some basic utilitis like tmux, vim jq, etc.
                        - Install Docker on both VMs uisng Ansible's Docker plugins in galaxy.
                        - Run on one of the VMs 2 Nginx containers and on the other VM run 2 Traefik containers.
                        - Everything while the VM can't be accessed from the public internet, only via Tailscale.
					</p>

				    <p class="mt-4">
                        So here’s what this Ansible setup is doing. 
					</p>
					<div class="mt-6">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/inventory.ini
[workers]
a1 ansible_host=aws-worker-1
a2 ansible_host=aws-worker-2` }
						}
					</div>
				    <p class="mt-4">
                        First off, there’s an inventory — that’s how Ansible knows what machines exist and how to reach them.
                        Here, we have two machines — a1 and a2 — grouped under [workers].
                        When you run a playbook, you can target either the entire group (workers) or individual hosts.
                        Here the aws-worker-1 and aws-worker-2 are the MagicDNS hostnames for the two VMs, but you can use the IP addresses as well.
					</p>

					<div class="mt-6">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/requirements.yml
roles:
  - name: geerlingguy.docker
    version: 7.4.1

collections:
  - name: community.docker
    version: ">=3.0.0"` }
						}
					</div>
				    <p class="mt-4">
                        The requirements.yml file is used to define the roles and collections that are needed for the playbook.
                        In this case, we need the geerlingguy.docker role to install Docker on the machines.
                        And we need the community.docker collection to enable Ansible to interact with Docker.
					</p>

					<div class="mt-6">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`# ansible/playbook.yml
- name: Install dependencies
  hosts: workers
  become: yes
  roles:
    - base
    - geerlingguy.docker

- name: Install nginx on AWS Worker 1
  hosts: a1
  become: yes
  roles:
    - nginx

- name: Install traefik on AWS Worker 2
  hosts: a2
  become: yes
  roles:
    - traefik` }
						}
					</div>
				    <p class="mt-4">
                        This is the playbook that will be used to configure the two VMs.
                        It runs the base role to install some basic utilities and the geerlingguy.docker role to install Docker on both machines.
                        Then it configures Nginx on the first machine and Traefik on the second machine.
					</p>


					<div class="mt-6">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/roles/base/tasks/main.yml
- name: Install common utilities
  apt:
    name:
      - tmux
      - vim
      - jq
    state: present` }
						}
					</div>
				    <p class="mt-4">
                        This role is used to install tmux, vim, jq.
					</p>

				    <p class="mt-4">
                        Now I will describe the process for Nginx, for Traefik it is similar. 
					</p>

					<div class="mt-6">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/roles/nginx/tasks/main.yml
- name: Nginx Alpine
  import_tasks: nginx_alpine.yml

- name: Nginx Latest
  import_tasks: nginx_latest.yml` }
						}
					</div>
					<div class="mt-6">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/roles/nginx/tasks/nginx_alpine.yml
- name: Start nginx:alpine container
  community.docker.docker_container:
    name: nginx_alpine
    image: nginx:alpine
    state: started
    ports:
      - "8080:80"
    restart_policy: no` }
						}
					</div>
					<div class="mt-6">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/roles/nginx/tasks/nginx_latest.yml
- name: Start nginx:latest container
  community.docker.docker_container:
    name: nginx_latest
    image: nginx:latest
    state: started
    ports:
      - "8081:80"
    restart_policy: no` }
						}
					</div>
				    <p class="mt-4">
                        Here in the main.yml file we are importing the tasks for the Alpine and Latest versions of Nginx.
                        And we see that in the alpine file we are starting the nginx:alpine container on port 8080 and in the latest file we are starting the nginx:latest container on port 8081.
                        For Traefik it is similar.
					</p>

				    <p class="mt-4">
                        This is the Ansible setup, but we didn't discuss somehitng important yet.
                        Ansible uses SSH to connect to the remote hosts so in tipical setup we should do 2 things;
                        - Add a SSH key to the remote host so that Ansible can connect to it.
                        - Open port 22 on the remote host so that Ansible can connect to it.
                        In practice this creates some problems like now we have npw to manage a securly SSH keys and the open port 22 creates a security risk.
                        So to solve this problem we can use Tailscale to connect to the remote host.
                        Tailscale is a mesh VPN that allows you to connect to the remote host without opening any ports.
                        With it we can run our Ansible playbook on the remote host without opening any ports.
                        To achive this 2 things are requred.
                        - We need to install Tailscale on the remote host and to add it to our Tailscale network using --ssh flag in order to allow Ansible to connect to it via SSH.
                          It minmal setup should looks like this:
					</p>
					<div class="mt-6">
						@code.Code(code.Props{
							Language:       "bash",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`#!/usr/bin/env bash

apt-get update -y
apt-get install -y curl

curl -fsSL https://tailscale.com/install.sh | sh
tailscale up --authkey TAILSCALE_AUTH_KEY --hostname aws-worker-1 --ssh` }
						}
					</div>
                    <p class="mt-4">
                        SO everything to be automatic we will create a GitHub Action workflow that will be triggered every time we push a change to our repository that will run the Ansible playbook on the remote hosts.
                        In order to achive this we have to add the GitHub Action runner to our Tailscale network temporarily and then run the Ansible playbook on the remote hosts.
                        The setup should look like this:
                    </p>
					<div class="mt-6">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`# .github/workflows/ansible-run-playbook.yml
---
name: Ansible Run Playbook

on:
  push:
    branches:
      - main
    paths:
      - 'ansible/**'

jobs:
  run-playbook:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Set up Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      - name: Install Ansible roles
        run: ansible-galaxy install -r ansible/requirements.yml

      - name: Run Ansible playbook
        uses: dawidd6/action-ansible-playbook@v5
        with:
          playbook: ansible/playbook.yml
          options: |
            --inventory ansible/inventory.ini
            --user ubuntu
            --verbose` }
						}
					</div>

                    <p class="mt-4 mb-0">
                        So this is how you can use Ansible and Tailscale to manage your infrastructure without opening any ports to the public internet.
                    </p>
                    <ul class="list-disc list-inside mt-0 mb-0">
                        <li>
                            You can find the source code for this project
                            <a href="https://github.com/ip812/infra/tree/002fd55652cd9c85fa288119230138fa775742c0" class="text-blue-600 hover:underline" target="_blank" rel="noopener noreferrer"> 
                                here
                            </a>.
                        </li>
                        <li>
                            <a href="https://www.youtube.com/watch?v=9ZkzPYZTazY" class="text-blue-600 hover:underline" target="_blank" rel="noopener noreferrer"> 
                                Here
                            </a>
                            I recorded a video showing how to setup Tailscale and GitHub Action runner to run the Ansible playbook on the remote hosts.
                            If you have any questions or suggestions, feel free to connect with me on the social media or to write a comment below.
                        </li>
                    </ul>

					<div class="mt-12">
						<h2 class="text-2xl font-bold mb-4">Comments</h2>
						<hr class="border-t-2 border-gray-300 mb-6"/>
                        @components.CommentInputForm(components.CommentInputFormProps{
                            ArticleID: articles.AnsiblePlusTailsclaleEqualGreatComboID,
                        })
                        <div 
                            id="comments"
                            hx-get={ fmt.Sprintf("/api/public/v0/articles/%d/comments", articles.AnsiblePlusTailsclaleEqualGreatComboID) }
		                    hx-target="#comments"
		                    hx-swap="innerHTML"
                            hx-trigger="load"
                        >
                            <div class="mt-4">
                                @templates.Spinner() {}
                            </div>
                        </div>
					</div>
				</div>
			</div>
			@templates.Footer()
		</div>
	}
}
