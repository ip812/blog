package views

import (
	"fmt"

	"github.com/ip812/blog/articles"
	"github.com/ip812/blog/templates"
	"github.com/ip812/blog/templates/components"
	"github.com/ip812/blog/templates/button"
	"github.com/ip812/blog/templates/code"
)

var ansiblePlusTailsclaleEqualGreatComboIDMetadata = articles.GetByID(articles.AnsiblePlusTailsclaleEqualGreatComboID)

templ ArticleAnsiblePlusTailscaleEqualGreatCombo() {
	@templates.Base() {
		<div class="flex flex-col min-h-screen justify-between w-full">
			<div class="flex flex-1 justify-center">
				<div class="mx-auto w-4/5 md:w-1/2 max-w-prose space-y-8 py-12 font-medium">
					<div class="mb-6 flex justify-center">
						@button.Button(button.Props{
							Href: "/p/public/articles",
						}) {
							Go Back to Articles
						}
					</div>

					<header class="flex flex-col w-full justify-center items-center mb-2">
						<h1 class="text-3xl font-semibold leading-tight">{ ansiblePlusTailsclaleEqualGreatComboIDMetadata.Name }</h1>
					</header>

					<h2 id="introduction" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#introduction" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
							Introduction
						</a>
					</h2>
					<p class="mt-2">
						Before we jump into the concrete setup, here’s a short explanation of why this solution is useful. Originally, remote machines were configured manually — you logged in, ran commands, and called it a day. As the number of hosts grew and tasks became repetitive, people started writing ad‑hoc shell scripts to automate steps. That helped in the short term but led to many scattered scripts with inconsistent conventions, which made maintenance difficult.
					</p>

					<p class="mt-4">
						To solve that, teams adopted configuration‑management tools such as <strong>Ansible</strong>, Puppet, Chef, and Salt. Containerization and orchestration (Docker, then Kubernetes) added higher‑level primitives for running and scaling distributed applications. Kubernetes is powerful for large, dynamic clusters, but for small deployments it often adds unnecessary complexity and operational overhead.
					</p>

					<p class="mt-4">
						For a single machine or a handful of hosts, a configuration‑management approach with <strong>Ansible</strong> is usually simpler, more maintainable, and easier to reason about. In this post I’ll show how to use Ansible to manage Docker containers on remote hosts that live in private networks — and how to access them securely using <strong>Tailscale</strong> so you don’t need to open public ports or manage SSH keys manually.
					</p>

					<p class="mt-4">
						The idea is simple: if a machine is joined to our Tailscale network and SSH access is enabled, Ansible can connect to it because Ansible uses SSH. To run Ansible automatically whenever we change our repository, we’ll add a GitHub Actions workflow that runs on push. For the workflow runner to reach machines on Tailscale, we’ll temporarily add the runner to our Tailscale network using Tailscale’s GitHub Action.
					</p>

					<p class="mt-4">
						This demo configures two AWS VMs to:
					</p>
					<ul class="list-disc list-inside space-y-2">
						<li>Install common utilities (tmux, vim, jq, etc.)</li>
						<li>Install Docker using Ansible roles/collections</li>
						<li>Run two Nginx containers on one VM and two Traefik containers on the other</li>
						<li>Keep both VMs inaccessible from the public internet — reachable only via Tailscale</li>
					</ul>


					<h2 id="prerequisites" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#prerequisites" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Prerequisites and Setup">
							Prerequisites and Setup
						</a>
					</h2>
					<ul class="list-disc list-inside space-y-1 mt-0">
						<li>Install Tailscale on each target host.</li>
						<li>Join each host to your tailnet with SSH enabled (<strong>--ssh</strong>).</li>
						<li>Ensure the hostnames are resolvable via Tailscale MagicDNS.</li>
					</ul>

					<div class="mt-4">
						@code.Code(code.Props{
							Language:       "bash",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`#!/usr/bin/env bash

apt-get update -y
apt-get install -y curl

curl -fsSL https://tailscale.com/install.sh | sh
tailscale up --authkey TAILSCALE_AUTH_KEY --hostname aws-worker-1 --ssh` }
						}
					</div>

					<h2 id="inventory" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#inventory" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Inventory">
							Inventory
						</a>
					</h2>
					<div class="mt-4">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/inventory.ini
[workers]
a1 ansible_host=aws-worker-1
a2 ansible_host=aws-worker-2` }
						}
					</div>

					<ul class="list-disc list-inside mt-3 space-y-1">
						<li>Defines group <strong>workers</strong> containing hosts <strong>a1</strong> and <strong>a2</strong>.</li>
						<li><strong>ansible_host</strong> points to Tailscale MagicDNS names (IPs also work).</li>
					</ul>

					<h2 id="requirements" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#requirements" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Ansible Requirements">
							Ansible Requirements
						</a>
					</h2>
					<div class="mt-4">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/requirements.yml
roles:
  - name: geerlingguy.docker
    version: 7.4.1

collections:
  - name: community.docker
    version: ">=3.0.0"` }
						}
					</div>

					<ul class="list-disc list-inside mt-3 space-y-1">
						<li><strong>geerlingguy.docker</strong> role: installs Docker.</li>
						<li><strong>community.docker</strong> collection: modules for managing containers.</li>
					</ul>

					<h2 id="playbook" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#playbook" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Playbook">
							Playbook
						</a>
					</h2>
					<div class="mt-4">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`# ansible/playbook.yml
- name: Install dependencies
  hosts: workers
  become: yes
  roles:
    - base
    - geerlingguy.docker

- name: Install nginx on AWS Worker 1
  hosts: a1
  become: yes
  roles:
    - nginx

- name: Install traefik on AWS Worker 2
  hosts: a2
  become: yes
  roles:
    - traefik` }
						}
					</div>

					<ul class="list-disc list-inside space-y-2 mt-3">
						<li>Installs common utilities and Docker on all workers (<strong>base</strong> and <strong>geerlingguy.docker</strong> roles).</li>
						<li>Deploys Nginx on <strong>a1</strong> and Traefik on <strong>a2</strong>.</li>
					</ul>

					<h3 id="role-base" class="text-xl font-bold mt-6 mb-3 group">
						<a href="#role-base" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Base Role">
							Base Role
						</a>
					</h3>
					<div class="mt-4">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/roles/base/tasks/main.yml
- name: Install common utilities
  apt:
    name:
      - tmux
      - vim
      - jq
    state: present` }
						}
					</div>

					<ul class="list-disc list-inside mt-3 space-y-1">
						<li>Installs a small set of common CLI tools across all hosts.</li>
					</ul>

					<h3 id="role-nginx" class="text-xl font-bold mt-6 mb-3 group">
						<a href="#role-nginx" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Nginx Role">
							Nginx Role
						</a>
					</h3>
					<ul class="list-disc list-inside mt-0 mb-2 space-y-1">
						<li>Tasks are split to keep responsibilities clear and files small.</li>
					</ul>

					<div class="mt-3">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/roles/nginx/tasks/main.yml
- name: Nginx Alpine
  import_tasks: nginx_alpine.yml

- name: Nginx Latest
  import_tasks: nginx_latest.yml` }
						}
					</div>

					<div class="mt-2">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/roles/nginx/tasks/nginx_alpine.yml
- name: Start nginx:alpine container
  community.docker.docker_container:
    name: nginx_alpine
    image: nginx:alpine
    state: started
    ports:
      - "8080:80"
    restart_policy: no` }
						}
					</div>

					<div class="mt-2">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeSm,
						}) {
							{ 
`# ansible/roles/nginx/tasks/nginx_latest.yml
- name: Start nginx:latest container
  community.docker.docker_container:
    name: nginx_latest
    image: nginx:latest
    state: started
    ports:
      - "8081:80"
    restart_policy: no` }
						}
					</div>

					<h2 id="ci-workflow" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#ci-workflow" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to CI Workflow">
							CI Workflow
						</a>
					</h2>
					<p class="mt-0">
						To run Ansible from CI, the workflow does four things:
					</p>
					<ol class="list-decimal list-inside space-y-2 mt-2">
						<li>Check out the repository.</li>
						<li>Temporarily add the runner to your Tailscale network using the Tailscale GitHub Action.</li>
						<li>Install Ansible roles.</li>
						<li>Run the playbook against the Tailscale-accessible hosts.</li>
					</ol>

					<div class="mt-4">
						@code.Code(code.Props{
							Language:       "yaml",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`# .github/workflows/ansible-run-playbook.yml
---
name: Ansible Run Playbook

on:
  push:
    branches:
      - main
    paths:
      - 'ansible/**'

jobs:
  run-playbook:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Set up Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      - name: Install Ansible roles
        run: ansible-galaxy install -r ansible/requirements.yml

      - name: Run Ansible playbook
        uses: dawidd6/action-ansible-playbook@v5
        with:
          playbook: ansible/playbook.yml
          options: |
            --inventory ansible/inventory.ini
            --user ubuntu
            --verbose` }
						}
					</div>

					<h2 id="conclusion" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#conclusion" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Conclusion">
							Conclusion
						</a>
					</h2>
					<p class="mt-0">
						Use Tailscale to avoid exposing SSH, and run Ansible from a temporary Tailscale-connected GitHub Actions runner to manage private hosts safely.
					</p>

					<ul class="list-disc list-inside mt-2 space-y-2">
						<li>
							You can find the source code for this project
							<a href="https://github.com/iypetrov/ansible-with-tailscale/tree/38ad005bf842ad668469b7497407f3adf1a45d4e" class="text-blue-600 hover:underline" target="_blank" rel="noopener noreferrer">
								here
							</a>.
						</li>
						<li>
							A live demo is available
							<a href="https://www.youtube.com/watch?v=rznH28MA8xE" class="text-blue-600 hover:underline" target="_blank" rel="noopener noreferrer">
								here
							</a>.
						</li>
					</ul>

					<div class="mt-10">
						<h2 class="text-2xl font-bold mb-4">Comments</h2>
						<hr class="border-t-2 border-gray-300 mb-6"/>
						@components.CommentInputForm(components.CommentInputFormProps{
							ArticleID: articles.AnsiblePlusTailsclaleEqualGreatComboID,
						})
						<div
							id="comments"
							hx-get={fmt.Sprintf("/api/public/v0/articles/%d/comments", articles.AnsiblePlusTailsclaleEqualGreatComboID)}
							hx-target="#comments"
							hx-swap="innerHTML"
							hx-trigger="load"
						>
							<div class="mt-4">
								@templates.Spinner() {}
							</div>
						</div>
					</div>
				</div>
			</div>
			@templates.Footer()
		</div>
	}
}
