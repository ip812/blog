package views

import (
	"fmt"
	"github.com/ip812/blog/articles"
	"github.com/ip812/blog/templates"
	"github.com/ip812/blog/templates/button"
	"github.com/ip812/blog/templates/code"
	"github.com/ip812/blog/templates/components"
)

var deferDeepDiveMetadata = articles.GetByID(articles.DeferDeepDiveID)

templ ArticleDeferDeepDive() {
	@templates.Base() {
		<div class="flex flex-col min-h-screen justify-between w-full">
			<div class="flex flex-1 justify-center">
				<div class="mx-auto w-4/5 md:w-1/2 space-y-8 py-12 font-medium">
					<div class="mb-8 flex justify-center">
						@button.Button(button.Props{
							Href: "/p/public/articles",
						}) {
							Go Back to Articles
						}
					</div>
					<header class="flex flex-col w-full justify-center items-center mb-2">
						<h1 class="text-3xl font-semibold leading-tight">{ deferDeepDiveMetadata.Name }</h1>
						<h3 class="text-md text-gray-500 mt-2 font-bold">{ fmt.Sprintf("%d min read", deferDeepDiveMetadata.ReadTimeMinutes) }</h3>
					</header>
					<h2 id="introduction" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#introduction" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
							Introduction
						</a>
					</h2>
					<p class="mt-2">
						<b>defer</b> is a keyword in Go that allows developers to schedule a function call to be executed when the surrounding function returns.
						This powerful feature guarantees that the deferred function will run on every exit path—whether the function completes normally or exits due to a panic.
						The concept is similar to RAII in C++ or try–finally in Java: cleanup or finalization logic is guaranteed to run when control leaves a scope.
						In this article, I’ll explain how <b>defer</b> works, explore common usage patterns, and highlight frequent pitfalls—and how to avoid them.
					</p>
					<h2 id="overview" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#overview" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
							Overview
						</a>
					</h2>
					<p class="mt-2">
						Let's start with a simple example to illustrate how <b>defer</b> works in Go.
						Consider the following code snippet:
					</p>
					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`func readFile(filename string) (string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return "", err
	}

	buffer := make([]byte, 100)
	_, err = file.Read(buffer)
	if err != nil {
        file.Close()
		return "", err
	}

    file.Close()
	return string(buffer), nil
}` }
						}
					</div>
					<p>
						In this example, we open a file and read its contents. However, if an error occurs during the read operation, we must remember to close the file before returning.
						This can lead to code duplication and potential resource leaks if we forget to close the file in every error path.
						In this case it is easy to spot all the return paths, but in more complex functions it can be easy to miss one.
						To address this issue, we can use <b>defer</b> to ensure that the file is closed when the function exits, regardless of how it exits:
					</p>
					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`func readFile(filename string) (string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return "", err
	}
    defer file.Close()

	buffer := make([]byte, 100)
	_, err = file.Read(buffer)
	if err != nil {
		return "", err
	}

	return string(buffer), nil
}` }
						}
					</div>
					<p>
						In this revised version, we use <b>defer file.Close()</b> immediately after opening the file.
						This ensures that the file will be closed when the function returns, regardless of whether it returns due to an error or completes successfully.
						This not only simplifies the code but also enhances its readability and maintainability.
					</p>
					<h2 id="threedeferrules" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#threedeferrules" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
							3 Rules of Defer
						</a>
					</h2>
					<p class="mt-2">
						Above we saw a basic usage of <b>defer</b>, but there are some important rules and best practices to keep in mind when using it.
						Here are three important rules to keep in mind when using <b>defer</b> in Go:
					</p>
					<h2 id="ruleone" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#ruleone" class="text-xl text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
							Rule 1: Deferred function calls are executed in Last In First Out order after the surrounding function returns
						</a>
					</h2>
					<p class="mt-2">
						This means that if you have multiple <b>defer</b> statements in a function, they will be executed in reverse order(LIFO) of their appearance when the function exits.
					</p>
					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`func lifo() {
	fmt.Println("LIFO")
	defer fmt.Println("First Deferred")
	defer fmt.Println("Second Deferred")
	defer fmt.Println("Third Deferred")
}
// LIFO
// Third Deferred
// Second Deferred
// First Deferred` }
						}
					</div>
					<h2 id="ruletwo" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#ruletwo" class="text-xl text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
							Rule 2: A deferred function’s arguments are evaluated when the defer statement is evaluate 
						</a>
					</h2>
					<p class="mt-2">
						When using <b>defer</b>, keep in mind that all arguments—including the receiver—are evaluated right away, not when the deferred function runs. 
						The example below demonstrates this:
					</p>
					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`func captureByValue()  {
	file := "file1.txt"
	defer printFileContent(file)

	file = "file2.txt"
}` }
						}
					</div>
					<p class="mt-2">
						In this example, file is evaluated immediately when the <b>defer</b> statement is encountered. 
						That means when <b>printFileContent</b> is eventually called, it still refers to <b>"file1.txt"</b>, even though file was later reassigned to <b>"file2.txt"</b>.
						This behavior can feel unintuitive at first, but it’s deliberate. 
						When you reuse a variable to open multiple files, deferring <b>Close</b> ensures that each file is closed correctly—at the point it was opened—rather than closing only the last one.
					</p>
					<p class="mt-2">
						However, if you want to avoid this behaviour there are two common approaches:
					</p>
					<h3 id="ruletwoclosure" class="text-2xl font-bold mb-2 group">
						<a href="#ruletwoclosure" class="text-xl text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
							Use a closure to capture the variable by reference 
						</a>
					</h3>
					<p>
						This means wrapping the deferred function call inside another function. That way, you capture the variable by reference, not by value like before. 
						Variables referenced by a defer closure are evaluated during the closure execution(hence, when the surrounding function returns).
						The implementation looks like this:
					</p>
					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`func captureByReferenceClosure()  {
	file := "file1.txt"
	defer func() {
		printFileContent(file)
	}()

	file = "file2.txt"
}

// content file2.txt` }
						}
					</div>
					<h3 id="ruletwomemoryaddress" class="text-2xl font-bold mb-2 group">
						<a href="#ruletwomemoryaddress" class="text-xl text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
							Pass the memory address of the variable instead of its value
						</a>
					</h3>
					<p>
						By passing a pointer to the variable, you ensure that the deferred function accesses the current value of the variable when it executes.
						However, usually using a closure is more idiomatic in Go.
						Here’s how you can implement this approach:
					</p>
					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`func captureByReferencePointer()  {
	file := "file1.txt"
	defer printFileContent(&file)

	file = "file2.txt"
}` }
						}
					</div>
					<h2 id="rulethree" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#rulethree" class="text-xl text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
							Rule 3: Deferred functions may read and assign to the returning function’s named return values
						</a>
					</h2>
					<p class="mt-2">
						If a function has named return values, deferred functions can access and modify those values before the function actually returns.
						This can be useful for setting return values based on cleanup operations or error handling.
						Popular example for this is in the case when we want to capture errors from the deferred function and return them:
					</p>
					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`type File struct {
	Name string
}

func Open(name string) (*File, error) {
	file := &File{Name: name}
	return file, nil
}

func (f *File) Close() error {
	return fmt.Errorf("Error closing file: %s", f.Name)
}

// Here we use the err named return value to capture errors from close
// the errors.Join function combines the error from the main function and the error from Close
func correctErrorHandling() (err error) {
	file, err := Open("nonexistent.txt")
	if err != nil {
		return err
	}
	defer func() {
		err = errors.Join(err, file.Close())
	}()

	return fmt.Errorf("Random error")
}

// Random error
// Error closing file: nonexistent.txt` }
						}
					</div>
					<h2 id="deferpanicrecover" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#deferpanicrecover" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Conclusion">
							Defer, Panics, and Recover
						</a>
					</h2>
					<p class="mt-2">
						In Go, when a panic occurs, the normal execution flow is interrupted, and the program starts unwinding the stack.
						The only way to recover from a panic is by using the <b>recover</b> function, which can only be called within a deferred function.
						This is true, because deferred functions are guaranteed to run when a function exits, even if it exits due to a panic.
						Here’s an example that demonstrates how <b>defer</b>, <b>panic</b>, and <b>recover</b> work together:
					</p>
					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`func foo() (err error) {
    defer func() {
        if r := recover(); r != nil {
	    		err = fmt.Errorf("no worries, recovered from panic: %v", r)
        }
  }()
	panic("trigger panic for demonstration")
}
// no worries, recovered from panic: trigger panic for demonstration}` }
						}
					</div>
					<h2 id="commonerrors" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#commonerrors" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Conclusion">
							Common Errors
						</a>
					</h2>
					<p class="mt-0">
						To wrap up, here I want to highlight 2 popular mistakes that newcomers to Go often make, when they start using <b>defer</b>:
					</p>
					<h2 id="errone" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#errone" class="text-xl text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
							Error 1: Always put the defer after error check 
						</a>
					</h2>
					<p class="mt-2">
						A common mistake is to place the <b>defer</b> statement before checking for errors when opening a resource.
						If the resource fails to open, the deferred function will attempt to Close non-existent resource, which is unwanted behavior.
						Always ensure that the resource is successfully opened before deferring its closure.
					</p>
					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`func wrongErrorHandling() {
	file, err := os.Open("nonexistent.txt")
	defer file.Close() // wrong, should be below error check
	if err != nil {
		fmt.Println("Error opening file:", err)
		return
	}
}

func correctErrorHandling() {
	file, err := os.Open("nonexistent.txt")
	if err != nil {
		fmt.Println("Error opening file:", err)
		return
	}
	defer file.Close() // correct
}` }
						}
					</div>
					<h2 id="errtwo" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#errtwo" class="text-xl text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
							Error 2: Don’t call defer in a loop
						</a>
					</h2>
					<p class="mt-2">
						Another common mistake is to place <b>defer</b> statements inside loops, since deferred functions are executed when the surrounding function returns.
						This means that if you defer a function inside a loop, all the deferred calls will accumulate and only execute after the entire function completes.
						This can lead to excessive resource usage and potential memory leaks.
					</p>
					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`func wrongReadFiles(files []string) error {
	for file := range files {
		f, err := os.Open(file)
		if err != nil {
			return err
		}

		defer f.Close() // Close will not be called till the end of the function
	}
	return nil
}` }
						}
					</div>
					<p class="mt-2">
						There are 2 popular ways to avoid this issue:
					</p>
					<h3 id="errtwoone" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#errtwoone" class="text-xl text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
							Use closures to manage resource lifetimes within the loop iteration
						</a>
					</h3>
					<p class="mt-2">
						By using an anonymous function, you can ensure that resources are properly closed at the end of each iteration.
					</p>
					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`func correctReadFilesClosure(files []string) error {
	for _, file := range files {
		err := func() error {
			f, err := os.Open(file)
			if err != nil {
				return err
			}

			defer f.Close()

			return nil
		}()
		if err != nil {
			return err
		}
	}
	return nil
}` }
						}
					</div>
					<h3 id="errtwotwo" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#errtwotwo" class="text-xl text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
							Use helper functions to encapsulate resource management
						</a>
					</h3>
					<p class="mt-2">
						By delegating resource management to a separate function, you can ensure that resources are properly closed after each operation.
						This is more popular way to handle this situation, as it leads to cleaner and more maintainable code.
						It's more readable than using closures in most cases.
						Furthermore we can test the helper function independently.
					</p>
					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`func readFile(file string) {
		f, err := os.Open(file)
		if err != nil {
			return err
		}

		defer f.Close()
}

func correctReadFiles(files []string) error {
	for file := range files {
		readFile(file)
	}
	return nil
}` }
						}
					</div>
					<h2 id="conclusion" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#conclusion" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Conclusion">
							Conclusion
						</a>
					</h2>
					<p class="mt-0">
						I hope after reading this article, that you have a deeper understanding of how <b>defer</b> works in Go.
						It is a powerful feature that, when used correctly, can greatly enhance the readability and maintainability of your code.
						By following best practices and being aware of common pitfalls, you can leverage <b>defer</b> to write cleaner and more efficient Go programs.
					</p>
					<div class="mt-12">
						<h2 class="text-2xl font-bold mb-4">Comments</h2>
						<hr class="border-t-2 border-gray-300 mb-6"/>
						@components.CommentInputForm(components.CommentInputFormProps{
							ArticleID: articles.DeferDeepDiveID,
						})
						<div
							id="comments"
							hx-get={ fmt.Sprintf("/api/public/v0/articles/%d/comments", articles.DeferDeepDiveID) }
							hx-target="#comments"
							hx-swap="innerHTML"
							hx-trigger="load"
						>
							<div class="mt-4">
								@templates.Spinner()
							</div>
						</div>
					</div>
				</div>
			</div>
			@templates.Footer()
		</div>
	}
}
