package views

import (
    "fmt"
	"github.com/ip812/blog/articles"
	"github.com/ip812/blog/templates"
	"github.com/ip812/blog/templates/components"
	"github.com/ip812/blog/templates/button"
	"github.com/ip812/blog/templates/code"
)

var deferDeepDiveMetadata = articles.GetByID(articles.DeferDeepDiveID)

templ ArticleDeferDeepDive() {
	@templates.Base() {
		<div class="flex flex-col min-h-screen justify-between w-full">
			<div class="flex flex-1 justify-center">
				<div class="mx-auto w-4/5 md:w-1/2 space-y-8 py-12 font-medium">
					<div class="mb-8 flex justify-center">
						@button.Button(button.Props{
							Href: "/p/public/articles",
						}) {
                            Go Back to Articles
						}
					</div>

					<header class="flex flex-col w-full justify-center items-center mb-2">
						<h1 class="text-3xl font-semibold leading-tight">{ deferDeepDiveMetadata.Name }</h1>
                        <h3 class="text-md text-gray-500 mt-2 font-bold">{ fmt.Sprintf("%d min read", deferDeepDiveMetadata.ReadTimeMinutes) }</h3>
					</header>

					<h2 id="introduction" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#introduction" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
							Introduction
						</a>
					</h2>
					<p class="mt-2">
                        <b>defer</b> is a keyword in Go that allows developers to schedule a function call to be executed when the surrounding function returns.
                        This powerful feature guarantees that the deferred function will run on every exit path—whether the function completes normally or exits due to a panic.
                        The concept is similar to RAII in C++ or try–finally in Java: cleanup or finalization logic is guaranteed to run when control leaves a scope.
                        In this article, I’ll explain how <b>defer</b> works, explore common usage patterns, and highlight frequent pitfalls—and how to avoid them.
					</p>

					<h2 id="overview" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#overview" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
						    Overview
						</a>
					</h2>
					<p class="mt-2">
                        Let's start with a simple example to illustrate how <b>defer</b> works in Go.
                        Consider the following code snippet:
					</p>

					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`func readFile(filename string) (string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return "", err
	}

	buffer := make([]byte, 100)
	_, err = file.Read(buffer)
	if err != nil {
        file.Close()
		return "", err
	}

    file.Close()
	return string(buffer), nil
}` }
						}
					</div>
					<p>
                        In this example, we open a file and read its contents. However, if an error occurs during the read operation, we must remember to close the file before returning.
                        This can lead to code duplication and potential resource leaks if we forget to close the file in every error path.
                        In this case it is easy to spot all the return paths, but in more complex functions it can be easy to miss one.
                        To address this issue, we can use <b>defer</b> to ensure that the file is closed when the function exits, regardless of how it exits:
					</p>
					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`func readFile(filename string) (string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return "", err
	}
    defer file.Close()

	buffer := make([]byte, 100)
	_, err = file.Read(buffer)
	if err != nil {
		return "", err
	}

	return string(buffer), nil
}` }
						}
					</div>
                    <p>
                        In this revised version, we use <b>defer file.Close()</b> immediately after opening the file.
                        This ensures that the file will be closed when the function returns, regardless of whether it returns due to an error or completes successfully.
                        This not only simplifies the code but also enhances its readability and maintainability.
                    </p>

					<h2 id="threedeferrules" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#threedeferrules" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
						    3 Rules of Defer
						</a>
					</h2>
                    <p class="mt-2">
                        Above we saw a basic usage of <b>defer</b>, but there are some important rules and best practices to keep in mind when using it.
                        Here are three important rules to keep in mind when using <b>defer</b> in Go:
                    </p>

					<h2 id="ruleone" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#ruleone" class="text-xl text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
						    Rule 1: Deferred function calls are executed in Last In First Out order after the surrounding function returns
						</a>
					</h2>

                    <p class="mt-2">
                        This means that if you have multiple <b>defer</b> statements in a function, they will be executed in reverse order(LIFO) of their appearance when the function exits.
                    </p>

					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`func lifo() {
	fmt.Println("LIFO")
	defer fmt.Println("First Deferred")
	defer fmt.Println("Second Deferred")
	defer fmt.Println("Third Deferred")
}
// LIFO
// Third Deferred
// Second Deferred
// First Deferred` }
						}
					</div>

					<h2 id="ruletwo" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#ruletwo" class="text-xl text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
						    Rule 2: A deferred function’s arguments are evaluated when the defer statement is evaluate 
						</a>
					</h2>

                    <p class="mt-2">
                        When using <b>defer</b>, keep in mind that all arguments—including the receiver—are evaluated right away, not when the deferred function runs. 
                        The example below demonstrates this:
                    </p>

					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`func captureByValue()  {
	file := "file1.txt"
	defer printFileContent(file)

	file = "file2.txt"
}` }
						}
					</div>

                    <p class="mt-2">
                        In this example, file is evaluated immediately when the <b>defer</b> statement is encountered. 
                        That means when <b>printFileContent</b> is eventually called, it still refers to <b>"file1.txt"</b>, even though file was later reassigned to <b>"file2.txt"</b>.
                        This behavior can feel unintuitive at first, but it’s deliberate. 
                        When you reuse a variable to open multiple files, deferring <b>Close</b> ensures that each file is closed correctly—at the point it was opened—rather than closing only the last one.
                    </p>
                    <p class="mt-2">
                        However, if you want to avoid this behaviour there are two common approaches:
                    </p>

					<h3 id="ruletwoclousre" class="text-2xl font-bold mb-2 group">
						<a href="#ruletwoclosure" class="text-xl text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
						    Use a closure to capture the variable by reference 
						</a>
					</h3>

                    <p>
                        This means wrapping the deferred function call inside another function. That way, you capture the variable by reference, not by value like before. 
                        Variables referenced by a defer closure are evaluated during the closure execution(hence, when the surrounding function returns).
                        The implementation looks like this:
                    </p>

					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`func captureByReferenceClosure()  {
	file := "file1.txt"
	defer func() {
		printFileContent(file)
	}()

	file = "file2.txt"
}

// content file2.txt` }
						}
					</div>

					<h3 id="ruletwomemoryaddress" class="text-2xl font-bold mb-2 group">
						<a href="#ruletwomemoryaddress" class="text-xl text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
						    Pass the memory address of the variable instead of its value
						</a>
					</h3>

                    <p>
                        By passing a pointer to the variable, you ensure that the deferred function accesses the current value of the variable when it executes.
                        However, usually using a closure is more idiomatic in Go.
                        Here’s how you can implement this approach:
                    </p>

					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`func captureByReferencePointer()  {
	file := "file1.txt"
	defer printFileContent(&file)

	file = "file2.txt"
}` }
						}
					</div>

					<h2 id="rulethree" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#rulethree" class="text-xl text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Introduction">
						    Rule 3: Deferred functions may read and assign to the returning function’s named return values
						</a>
					</h2>

                    <p class="mt-2">
                        If a function has named return values, deferred functions can access and modify those values before the function actually returns.
                        This can be useful for setting return values based on cleanup operations or error handling.
                        Popular example for this is in the case when we want to capture errors from the deferred function and return them:
                    </p>

					<div>
						@code.Code(code.Props{
							Language:       "go",
							ShowCopyButton: true,
							Size:           code.SizeLg,
						}) {
							{ 
`type File struct {
	Name string
}

func Open(name string) (*File, error) {
	file := &File{Name: name}
	return file, nil
}

func (f *File) Close() error {
	return fmt.Errorf("Error closing file: %s", f.Name)
}

func correctErrorHandling() (err error) {
	file, err := Open("nonexistent.txt")
	if err != nil {
		return err
	}
	defer func() {
		err = errors.Join(err, file.Close())
	}()

	return fmt.Errorf("Random error")
}

// Random error
// Error closing file: nonexistent.txt` }
						}
					</div>

					<h2 id="conclusion" class="text-2xl font-bold mt-8 mb-4 group">
						<a href="#conclusion" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Conclusion">
							Conclusion
						</a>
					</h2>

					<p class="mt-0">
					    I hope after reading this article, that you have a deeper understanding of how <b>defer</b> works in Go.
                        It is a powerful feature that, when used correctly, can greatly enhance the readability and maintainability of your code.
                        By following best practices and being aware of common pitfalls, you can leverage <b>defer</b> to write cleaner and more efficient Go programs.
					</p>

					<div class="mt-12">
						<h2 class="text-2xl font-bold mb-4">Comments</h2>
						<hr class="border-t-2 border-gray-300 mb-6"/>
                        @components.CommentInputForm(components.CommentInputFormProps{
                            ArticleID: articles.DeferDeepDiveID,
                        })
                        <div 
                            id="comments"
                            hx-get={ fmt.Sprintf("/api/public/v0/articles/%d/comments", articles.DeferDeepDiveID) }
		                    hx-target="#comments"
		                    hx-swap="innerHTML"
                            hx-trigger="load"
                        >
                            <div class="mt-4">
                                @templates.Spinner() {}
                            </div>
                        </div>
					</div>
				</div>
			</div>
			@templates.Footer()
		</div>
	}
}
