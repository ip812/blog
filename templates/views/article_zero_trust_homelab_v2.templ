package views

import (
    "fmt"
	"github.com/ip812/blog/articles"
	"github.com/ip812/blog/templates"
	"github.com/ip812/blog/templates/components"
	"github.com/ip812/blog/templates/button"
	"github.com/ip812/blog/templates/code"
)

var zeroTrustHomelabV2Metadata = articles.GetByID(articles.ZeroTrustHomelabV2ID)

templ ArticleZeroTrustHomelabV2() {
	@templates.Base() {
		<div class="flex flex-col min-h-screen justify-between w-full">
			<div class="flex flex-1 justify-center">
				<div class="mx-auto w-4/5 md:w-1/2 space-y-8 py-12 font-medium">
					<div class="mb-8 flex justify-center">
						@button.Button(button.Props{
							Href: "/p/public/articles",
						}) {
						    Go Back to Articles
						}
					</div>

					<header class="flex flex-col w-full justify-center items-center mb-2">
						<h1 class="text-3xl font-semibold leading-tight">{ zeroTrustHomelabV2Metadata.Name }</h1>
                        <h3 class="text-md text-gray-500 mt-2 font-bold">{ fmt.Sprintf("%d min read", zeroTrustHomelabV2Metadata.ReadTimeMinutes) }</h3>
					</header>

				    <h2 id="motivation" class="text-2xl font-bold mt-8 mb-4 group">
				        <a href="#motivation" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to Motivation">
				            Motivation
				        </a>
				    </h2>

				    <p class="my-0">
				      In an earlier <a href="/p/public/articles/1417231583613554688" class="text-blue-600 hover:text-blue-800 underline">post</a> I described my homelab: a single EC2 instance running a small k3s cluster, with zero open ports to the public internet while still allowing secure remote access and selective app exposure. Here’s a quick recap:
				    </p>

				    <ul class="list-disc list-inside mt-0 mb-0">
				      <li>A single EC2 instance inside an Auto Scaling Group so the instance can be recreated in another AZ if it fails.</li>
				      <li>A security group that blocks all ingress while allowing outbound traffic.</li>
				      <li>A lightweight k3s cluster hosting my applications.</li>
				      <li>The instance is part of my Tailscale network, so I can securely access it without exposing ports.</li>
				      <li>cloudflared runs on the cluster to expose web apps through Cloudflare Tunnel — again, with zero open ports.</li>
				      <li>CloudnativePG provides Postgres on the cluster, with daily backups so I can restore after a VM recreation (RDS is a bit expensive for a homelab).</li>
				      <li>Metrics and logs are handled by Grafana Cloud: managed Prometheus for metrics and Loki for logs.</li>
				    </ul>

				    <p class="mt-4 mb-0">
				      The overall design worked well, but a few pain points motivated a rethink:
				    </p>

				    <ul class="list-disc list-inside mt-0 mb-0">
				      <li>
				        I managed both infrastructure and Kubernetes using Terraform. While Terraform is great for AWS resources, Grafana Cloud stacks, and DNS, it’s awkward for Kubernetes manifests and Helm charts. I split the work into two Terraform workspaces: one for infra (AWS, DNS, secrets) and one that consumed outputs from the first to render Helm/cluster resources. That caused friction: because my k3s cluster isn’t reachable except via Tailscale, Terraform Cloud’s remote runners couldn’t access it. My workaround was to run plans and applies locally — temporarily adding a GitHub Actions runner to my Tailscale network (there’s a helpful action for that) and performing the Terraform operations from that runner.
				      </li>
				      <li>
				        When the VM got recreated the k3s state was lost and I often had to re-run the k3s workspace manually. The usual workaround was to change something in the infra workspace so that the second workspace would be triggered — not robust. Additionally, managing Helm charts through Terraform has known pitfalls, especially when updating existing charts or forcing rollouts.
				      </li>
				    </ul>

				    <p class="mt-0 mb-0">
				      Those limitations pushed me to find a more robust, maintainable approach.
				    </p>

				    <h2 id="new-setup" class="text-2xl font-bold mt-8 mb-4 group">
				        <a href="#new-setup" class="text-gray-900 hover:text-blue-600 cursor-pointer" aria-label="Link to New Setup">
				            New setup
				        </a>
				    </h2>

                    <img class="w-full h-auto my-6" src="https://static.blog.ip812.com/zero-trust-homelab-v2-fluxcd-architecture.png" alt="FluxCD setup"/>

				    <p class="mt-0 mb-0">
				      My plan was to adopt GitOps with FluxCD to manage the cluster. Flux is lightweight compared to ArgoCD and a natural fit for managing Kubernetes resources and Helm charts from Git. With values.yaml checked into Git, you get a clean, reusable setup and straightforward configuration for each app.
				    </p>

				    <p class="mt-0 mb-0">
				      The main challenges I faced were:
				    </p>
				    <ul class="list-disc list-inside mt-0 mb-0">
				      <li>How to get non-sensitive values (DNS names, ARNs, etc.) produced by Terraform into the values.yaml files that FluxCD reads.</li>
				      <li>How to inject sensitive values (database passwords, tunnel token, API keys, etc.) from Terraform into Kubernetes secrets securely.</li>
				    </ul>

				    <p class="mt-4 mb-0">
				      I keep secrets in Terraform Cloud for convenience and to access auto-generated outputs (for example, DNS records). I looked for a clean way to get those values into Git-managed values.yaml files and to deliver sensitive values into Kubernetes without exposing them in Git. The solution I built has two pieces:
				    </p>

				    <p class="mt-0 mb-0">
				      1) A small Terraform provider(
				         <a href="https://registry.terraform.io/providers/ip812/gitsync/latest" class="text-blue-600 hover:underline" target="_blank" rel="noopener noreferrer">ip812/gitsync</a>)
                         that syncs value files in a Git repo — it updates values.yaml with non-sensitive outputs from Terraform so FluxCD can pick them up and reconcile the cluster.
				    </p>

				<div class="my-0">
					@code.Code(code.Props{
						Language:       "go",
						ShowCopyButton: true,
						Size:           code.SizeFull,
					}) {
						{ 
`resource "gitsync_values_yaml" "go-template" {
  branch  = "main"
  path    = "values/${local.go_template_app_name}.yaml"
  content = <<EOT
isInit: false
name: "${local.go_template_app_name}"
image: "ghcr.io/iypetrov/go-template:1.15.0"
hostname: "${cloudflare_dns_record.go_template_dns_record.name}"
replicas: 1
minMemory: "64Mi"
maxMemory: "128Mi"
minCPU: "50m"
maxCPU: "100m"
healthCheckEndpoint: "/healthz"
env:
  - name: APP_ENV
    value: "${local.env}"
  - name: APP_DOMAIN
    value: "${cloudflare_dns_record.go_template_dns_record.name}"
  - name: APP_PORT
    value: "8080"
  - name: DB_NAME
    value: "${local.go_template_db_name}"
  - name: DB_USERNAME
    valueFrom:
      secretKeyRef:
        name: "${local.go_template_app_name}-creds"
        key: PG_USERNAME
  - name: DB_PASSWORD
    valueFrom:
      secretKeyRef:
        name: "${local.go_template_app_name}-creds"
        key: PG_PASSWORD
  - name: DB_ENDPOINT
    value: "${local.go_template_db_name}-pg-rw.${local.go_template_app_name}.svc.cluster.local"
  - name: DB_SSL_MODE
    value: disable
database:
  postgres:
    name: "${local.go_template_db_name}"
    host: "${local.go_template_db_name}-pg-rw.${local.go_template_app_name}.svc.cluster.local"
    image: "ghcr.io/cloudnative-pg/postgresql:16.1"
    username: "${var.pg_username}"
    storageSize: "1Gi"
    retentionPolicy: "7d"
    backupsBucket: "${aws_s3_bucket.pg_backups.bucket}"
    backupSchedule: "0 0 0 * * *"
EOT
}` } 
					}
				</div>

				    <p class="mt-0 mb-0">
				      The important part is that sensitive values are not stored in the committed values.yaml — instead, they are referenced from Kubernetes secrets by name.
				    </p>

				    <p class="mt-4 mb-0">
				      2) For secret management I chose Doppler. HashiCorp Vault Dedicated is far too expensive for a hobby project(at the time of writing ~457$ per month), while Doppler offers a generous free tier plus good Terraform and Kubernetes integrations.
                      Creating a secret in Doppler looks like this:
				    </p>

				<div class="my-0">
					@code.Code(code.Props{
						Language:       "go",
						ShowCopyButton: true,
						Size:           code.SizeFull,
					}) {
						{ 
`resource "doppler_secret" "pg_password" {
  project = "prod"
  config  = "prd"
  name    = "PG_PASSWORD"
  value   = var.pg_password
}` } 
					}
				</div>

				    <p class="mt-0 mb-0">
				      From Doppler I generate Kubernetes secrets (the Doppler Kubernetes operator supports processors to transform key names if necessary). Example:
				    </p>

				<div class="my-0">
					@code.Code(code.Props{
						Language:       "yaml",
						ShowCopyButton: true,
						Size:           code.SizeFull,
					}) {
						{ 
`---
apiVersion: secrets.doppler.com/v1alpha1
kind: DopplerSecret
metadata:
  name: ghcr-auth-go-template
  namespace: doppler-operator-system
spec:
  tokenSecret: 
    name: doppler-token-secret
  project: prod
  config: prd
  managedSecret:
    name: ghcr-auth
    namespace: go-template
    type: kubernetes.io/dockerconfigjson
  processors:
    GHCR_DOCKERCONFIGJSON:
      type: plain
      asName: .dockerconfigjson` } 
					}
				</div>

				    <p class="mt-4 mb-0">
				      With this setup the infra repository (Terraform) owns the source of truth for infrastructure and secrets. When Terraform produces values that should land in the cluster, the gitsync provider writes non-sensitive values into the values.yaml files in Git (Flux picks them up). Sensitive values live in Doppler and are projected into Kubernetes secrets via the Doppler operator. FluxCD reconciles the cluster from the Git repo, and Kubernetes pulls secrets from Doppler — no secrets committed to Git and no awkward Terraform workspace choreography.
				    </p>

				    <p class="mt-4 mb-0">
				      I consider this my final GitOps-driven iteration for the homelab: a blend of Terraform for infra, FluxCD for cluster reconciliation, a small gitsync bridge for non-sensitive outputs, and Doppler for secrets. The result is simpler, more reliable, and easier to manage — and the approach scales beyond homelabs to production environments.
				    </p>

				    <p class="mt-4 mb-0">
				      If you have questions or suggestions, jump into the comments or find me on social media. The infra repo is available
				      <a href="https://github.com/ip812/infra/tree/d4e2cffc171350b2e3e5f9297e9714674229cf02" class="text-blue-600 hover:underline" target="_blank" rel="noopener noreferrer">here</a>
				      and the apps repo is <a href="https://github.com/ip812/apps/tree/1c94cb8e71238c501ca5a29f6342b2cf2924de97" class="text-blue-600 hover:underline" target="_blank" rel="noopener noreferrer">here</a>.
				    </p>

					<div class="mt-12">
						<h2 class="text-2xl font-bold mb-4">Comments</h2>
						<hr class="border-t-2 border-gray-300 mb-6"/>
					    @components.CommentInputForm(components.CommentInputFormProps{
					        ArticleID: articles.ZeroTrustHomelabV2ID,
					    })
					    <div 
					        id="comments"
					        hx-get={ fmt.Sprintf("/api/public/v0/articles/%d/comments", articles.ZeroTrustHomelabV2ID) }
					        hx-target="#comments"
					        hx-swap="innerHTML"
					        hx-trigger="load"
					    >
					        <div class="mt-4">
					            @templates.Spinner() {}
					        </div>
					    </div>
					</div>
				</div>
			</div>
			@templates.Footer()
		</div>
	}
}
